# 프로젝트 헌법

## 목적
이 헌법은 프로젝트의 핵심 원칙과 표준을 정의하여 모든 개발 활동에서 코드 품질, 테스트 관행, 사용자 경험, 성능의 일관성을 보장합니다.

---

## 1. 코드 품질 원칙

### 1.1 코드 가독성
- **명확성 우선**: 이해하기 쉬운 코드를 작성하세요. 암묵적 동작보다 명시적 동작을 선호합니다.
- **자기 문서화**: 목적과 의도를 명확히 전달하는 설명적인 변수명과 함수명을 사용하세요.
- **일관된 스타일**: 확립된 스타일 가이드와 린팅 규칙을 준수하세요. 병합 전 모든 코드는 자동화된 스타일 검사를 통과해야 합니다.
- **의미 있는 주석**: 코드가 "무엇을" 하는지가 아닌 "왜" 그렇게 결정했는지를 설명하는 주석을 추가하세요.

### 1.2 코드 구조
- **단일 책임**: 각 함수, 클래스, 모듈은 하나의 명확한 목적을 가져야 합니다.
- **DRY 원칙**: 반복하지 마세요. 공통 로직은 재사용 가능한 함수나 모듈로 추출하세요.
- **모듈화 설계**: 컴포넌트는 느슨하게 결합되고 높은 응집도를 유지해야 합니다. 의존성은 명시적이고 최소화되어야 합니다.
- **파일 구조**: 일관된 디렉토리 구조를 따르세요. 관련 파일은 논리적으로 그룹화되어야 합니다.

### 1.3 코드 리뷰 표준
- **모든 변경사항은 리뷰 필수**: 최소 한 명의 동료 리뷰 없이는 코드를 병합할 수 없습니다.
- **건설적인 피드백**: 리뷰는 철저하고, 존중하며, 교육적이어야 합니다.
- **리뷰 체크리스트**: 정확성, 가독성, 테스트 커버리지, 보안 취약점, 성능 영향을 확인하세요.
- **적시 리뷰**: 가능한 경우 요청 후 24시간 이내에 리뷰를 완료해야 합니다.

### 1.4 에러 처리
- **빠른 실패**: 가능한 한 빨리 오류를 감지하고 보고하세요.
- **의미 있는 에러 메시지**: 문제를 빠르게 진단하고 수정하는 데 도움이 되는 컨텍스트를 제공하세요.
- **우아한 성능 저하**: 시스템 안정성과 사용자 경험을 유지하는 방식으로 오류를 처리하세요.
- **로깅**: 디버깅에 충분한 컨텍스트와 적절한 심각도 수준으로 오류를 기록하세요.

### 1.5 한국어 주석 작성 규칙
- **모든 코드에 한국어 주석**: 함수, 클래스, 복잡한 로직에는 반드시 한국어 주석을 작성하세요.
- **간단명료하게**: 주석은 짧고 명확하게 작성하되, 이해에 필요한 모든 정보를 포함해야 합니다.
- **주석 작성 위치**:
  - 함수/메서드 위: 목적, 매개변수, 반환값 설명
  - 클래스 위: 클래스의 역할과 책임 설명
  - 복잡한 로직 앞: 왜 이렇게 구현했는지 설명
  - 중요한 변수 옆: 변수의 용도 설명
- **주석 내용 가이드**:
  - "무엇을" 하는지보다 "왜" 그렇게 했는지 설명
  - 비즈니스 로직이나 도메인 지식 포함
  - 예외 케이스나 특별한 처리가 필요한 이유 설명
  - TODO, FIXME 등의 태그는 한국어로 설명 추가
- **주석 예시**:
  ```javascript
  // 사용자 인증 토큰을 검증하고 갱신합니다
  // 만료 시간이 5분 이내로 남은 경우 자동으로 갱신됩니다
  async function validateAndRefreshToken(token) {
    // ...
  }

  // NOTE: 레거시 API와의 호환성을 위해 날짜 형식을 YYYY-MM-DD로 변환
  const formattedDate = moment(date).format('YYYY-MM-DD');

  // FIXME: 대용량 데이터 처리 시 메모리 사용량이 높음 - 스트리밍 방식으로 개선 필요
  ```
- **주석 유지보수**: 코드가 변경되면 관련 주석도 반드시 함께 업데이트하세요.
- **과도한 주석 지양**: 코드 자체로 명확한 경우 불필요한 주석은 작성하지 마세요.

---

## 2. 테스트 표준

### 2.1 테스트 커버리지 요구사항
- **최소 커버리지**: 모든 새 코드에 대해 최소 80%의 코드 커버리지를 유지하세요.
- **핵심 경로**: 비즈니스 크리티컬 기능은 100% 테스트 커버리지를 가져야 합니다.
- **커버리지 보고서**: 모든 풀 리퀘스트마다 커버리지 보고서를 생성하고 검토하세요.
- **커버리지 회귀 방지**: 새로운 변경사항이 전체 테스트 커버리지를 낮춰서는 안 됩니다.

### 2.2 테스트 유형 및 전략
- **유닛 테스트**: 개별 함수와 메서드를 격리하여 테스트하세요. 빨라야 합니다(테스트당 <10ms).
- **통합 테스트**: 컴포넌트가 올바르게 함께 작동하는지 확인하세요. API 엔드포인트, 데이터베이스 상호작용, 서비스 통합을 테스트하세요.
- **E2E 테스트**: 사용자 관점에서 완전한 사용자 워크플로를 검증하세요.
- **성능 테스트**: 성능 요구사항이 충족되는지 확인하는 테스트를 포함하세요.

### 2.3 테스트 품질
- **명확한 테스트 이름**: 테스트 이름은 무엇을 테스트하는지와 예상 결과를 설명해야 합니다.
- **준비-실행-검증**: AAA(Arrange-Act-Assert) 패턴을 따르세요.
- **테스트 독립성**: 테스트는 서로 또는 공유 상태에 의존해서는 안 됩니다. 각 테스트는 독립적으로 실행 가능해야 합니다.
- **외부 의존성 모킹**: 테스트가 빠르고 안정적이도록 외부 서비스에 대해 모킹, 스텁, 페이크를 사용하세요.
- **경계 케이스 테스트**: 경계 조건, 오류 케이스, 예상치 못한 입력에 대한 테스트를 포함하세요.

### 2.4 테스트 유지보수
- **문서로서의 테스트**: 테스트는 시스템 동작의 살아있는 문서 역할을 해야 합니다.
- **테스트 최신 유지**: 기능이 변경되면 즉시 테스트를 업데이트하세요.
- **구식 테스트 제거**: 제거된 기능에 대한 테스트는 즉시 삭제하세요.
- **무시된 테스트 금지**: 수정을 위한 추적 이슈와 타임라인 없이 건너뛰거나 비활성화된 테스트를 커밋하지 마세요.

---

## 3. 사용자 경험 일관성

### 3.1 디자인 시스템 준수
- **컴포넌트 라이브러리**: 확립된 디자인 시스템의 컴포넌트를 사용하세요. 필요할 때만 새 컴포넌트를 만드세요.
- **디자인 토큰**: 애플리케이션 전체에서 디자인 토큰(색상, 간격, 타이포그래피)을 일관되게 사용하세요.
- **시각적 일관성**: 인터페이스 전체에서 일관된 시각적 계층, 간격, 정렬을 유지하세요.
- **접근성 우선**: 최소 WCAG 2.1 AA 표준을 따르세요. 모든 상호작용 요소는 키보드로 접근 가능해야 합니다.

### 3.2 상호작용 패턴
- **일관된 동작**: 유사한 작업은 애플리케이션 전체에서 동일한 방식으로 작동해야 합니다.
- **피드백**: 모든 사용자 작업에 대해 즉각적인 시각적 피드백을 제공하세요(로딩 상태, 성공/오류 메시지).
- **예측 가능한 내비게이션**: 내비게이션 패턴은 일관되고 직관적이어야 합니다.
- **오류 복구**: 사용자가 오류에서 쉽게 복구할 수 있도록 하세요. 문제 해결 방법에 대한 명확한 안내를 제공하세요.

### 3.3 콘텐츠 및 메시징
- **명확한 언어**: 간단하고 직접적인 언어를 사용하세요. 대상에게 필요하지 않은 전문 용어는 피하세요.
- **일관된 톤**: 모든 사용자 대면 텍스트에서 일관된 목소리를 유지하세요.
- **에러 메시지**: 무엇이 잘못되었고 어떻게 수정하는지 설명하세요. 사용자 대면 오류에서 기술 전문 용어를 피하세요.
- **상황별 도움말**: 사용자가 안내가 필요할 수 있는 곳에 맥락적 도움말을 제공하세요.

### 3.4 반응형 디자인
- **모바일 우선**: 모바일 기기를 먼저 디자인하고 개발한 다음, 더 큰 화면에 맞게 향상시키세요.
- **중단점**: 애플리케이션 전체에서 일관된 중단점을 사용하세요.
- **터치 타겟**: 터치 접근성을 위해 상호작용 요소가 최소 44x44px인지 확인하세요.
- **콘텐츠 적응**: 콘텐츠는 기능 손실 없이 다양한 화면 크기에 우아하게 적응해야 합니다.

---

## 4. 성능 요구사항

### 4.1 로드 시간 목표
- **초기 페이지 로드**: 3G 연결에서 First Contentful Paint (FCP) < 1.5초
- **상호작용 가능 시간**: 3G 연결에서 페이지가 상호작용 가능해지는 시간 < 3초
- **최대 콘텐츠풀 페인트**: LCP < 2.5초
- **API 응답 시간**: 표준 엔드포인트에 대한 95백분위 응답 시간 < 500ms

### 4.2 런타임 성능
- **프레임 속도**: 모든 애니메이션과 상호작용에 대해 60fps 유지
- **메모리 사용**: 메모리 누수 없음. 초기 로드 후 메모리 사용량이 안정화되어야 함
- **번들 크기**: JavaScript 번들은 코드 분할 및 지연 로딩되어야 함. 초기 번들 < 200KB(gzip 압축)
- **이미지 최적화**: 모든 이미지는 최적화되고 폴백과 함께 최신 형식(WebP, AVIF)으로 제공되어야 함

### 4.3 성능 모니터링
- **지속적 모니터링**: RUM(Real User Monitoring)을 사용하여 실제 사용자 경험을 추적
- **성능 예산**: 번들 크기, 요청 수, 로드 시간에 대한 성능 예산 설정 및 시행
- **자동화된 테스트**: CI/CD 파이프라인에 성능 테스트 포함
- **회귀 감지**: 기준선에서 10% 이상 성능 회귀 시 알림

### 4.4 최적화 관행
- **효율적인 쿼리**: 데이터베이스 쿼리는 최적화되고 적절한 인덱스를 사용해야 함
- **캐싱 전략**: 적절한 계층(브라우저, CDN, 애플리케이션, 데이터베이스)에서 캐싱 구현
- **지연 로딩**: 필요할 때만 리소스를 로드. 코드 분할 및 지연 임포트 사용
- **디바운스/스로틀**: 사용자 입력으로 트리거되는 비용이 많이 드는 작업에 디바운싱과 스로틀링 사용
- **웹 바이탈**: Core Web Vitals(LCP, FID, CLS) 최적화

---

## 5. 보안 표준

### 5.1 보안 모범 사례
- **입력 검증**: 클라이언트와 서버 모두에서 모든 사용자 입력을 검증하고 살균
- **인증**: 안전한 인증 메커니즘 사용. 비밀번호를 평문으로 저장하지 않음
- **권한 부여**: 적절한 액세스 제어 구현. 모든 요청에서 권한 확인
- **HTTPS만 사용**: 모든 통신은 HTTPS를 사용해야 함. 예외 없음

### 5.2 의존성 관리
- **정기 업데이트**: 의존성을 최신 상태로 유지. 보안 권고사항을 정기적으로 검토
- **최소 의존성**: 필요하고 잘 유지되는 의존성만 포함
- **감사**: 정기적으로 보안 감사(npm audit 등) 실행 및 발견사항을 즉시 해결

---

## 6. 문서화 요구사항

### 6.1 코드 문서화
- **API 문서화**: 모든 공개 API는 명확한 설명, 매개변수, 예제와 함께 문서화되어야 함
- **README 파일**: 모든 모듈/패키지에는 목적과 사용법을 설명하는 README가 있어야 함
- **인라인 문서화**: 함수와 클래스 문서화를 위해 JSDoc, docstring 등을 사용

### 6.2 아키텍처 문서화
- **아키텍처 결정**: 중요한 아키텍처 결정과 그 이면의 이유를 문서화
- **시스템 다이어그램**: 시스템 아키텍처와 데이터 흐름을 보여주는 최신 다이어그램 유지
- **온보딩 가이드**: 신규 개발자를 위한 온보딩 가이드를 최신 상태로 유지

---

## 7. Git 커밋 및 버전 관리 규칙

### 7.1 커밋 빈도 및 단위
- **작고 자주 커밋**: 큰 변경사항을 한 번에 커밋하지 않고, 의미있는 작은 단위로 자주 커밋합니다.
- **커밋 타이밍**:
  - ✅ 파일 하나 생성 완료 시
  - ✅ 설정 하나 추가/수정 시
  - ✅ 함수/컴포넌트 하나 완성 시
  - ✅ 버그 하나 수정 시
  - ✅ 문서 섹션 하나 작성 시
  - ✅ 테스트 하나 추가 시
- **커밋 단위 원칙**: 각 커밋은 독립적으로 의미가 있어야 하며, 롤백 가능해야 합니다.

### 7.2 커밋 메시지 규칙
- **한국어 커밋 메시지**: 모든 커밋 메시지는 한국어로 작성합니다.
- **이모지 접두사 사용**:
  - ✅ 완료: [태스크 이름] - 태스크 완료 시
  - ✨ 기능: [기능 이름] - 새 기능 추가
  - 🐛 버그: [버그 내용] - 버그 수정
  - 📝 문서: [문서 내용] - 문서 수정/추가
  - 🎨 디자인: [변경 내용] - UI/UX 개선
  - ♻️ 리팩터링: [내용] - 코드 리팩터링
  - ⚡ 성능: [개선 내용] - 성능 개선
  - ✅ 테스트: [테스트 내용] - 테스트 추가/수정
  - 🔧 설정: [설정 내용] - 설정 파일 수정
  - 🚀 배포: [버전] - 배포 관련
- **커밋 메시지 구조**:
  ```
  [이모지] [타입]: [간단한 설명 (50자 이내)]

  [상세 설명 (선택사항)]
  - 변경 이유
  - 주요 변경 사항
  - 영향 범위
  ```

### 7.3 브랜치 전략
- **메인 브랜치**: `main` - 항상 배포 가능한 상태 유지
- **개발 브랜치**: `develop` - 개발 중인 기능 통합
- **기능 브랜치**: `feature/기능명` - 새 기능 개발
- **버그 수정 브랜치**: `bugfix/버그명` - 버그 수정
- **핫픽스 브랜치**: `hotfix/이슈명` - 긴급 수정

### 7.4 Pull Request 규칙
- **PR 크기**: 가능한 작게 유지 (변경 파일 10개 이하 권장)
- **PR 설명**: 변경 내용, 이유, 테스트 방법 명시
- **리뷰 필수**: 최소 1명의 승인 필요
- **테스트 통과**: 모든 자동화 테스트 통과 필수

### 7.5 자동 커밋 규칙 (AI Assistant용)
- **자동 커밋 활성화**: AI Assistant(Claude)는 태스크 완료 시 자동으로 커밋합니다.
- **커밋 빈도**: 파일 단위 또는 의미있는 작업 단위로 즉시 커밋
- **커밋 메시지**: 변경 내용을 분석하여 자동으로 한국어 커밋 메시지 생성
- **커밋 내용 요약**: 여러 파일이 변경된 경우, 커밋 메시지 본문에 상세 내용 포함

---

## 8. CI/CD (지속적 통합/배포)

### 8.1 CI/CD 파이프라인
- **자동화된 테스트**: 병합 전 모든 테스트가 통과해야 함
- **자동화된 린팅**: 병합 전 코드 스타일 검사가 통과해야 함
- **빌드 검증**: CI 환경에서 코드가 성공적으로 빌드되어야 함
- **성능 검사**: 자동화된 성능 테스트가 정의된 임계값을 충족해야 함

### 8.2 배포 표준
- **점진적 롤아웃**: 중요한 변경사항에 대해 기능 플래그 및 점진적 롤아웃 사용
- **롤백 능력**: 항상 배포를 빠르게 롤백할 수 있는 능력 유지
- **모니터링**: 배포 후 애플리케이션 상태와 사용자 경험 모니터링

---

## 9. 우수성에 대한 약속

모든 팀 구성원은 이러한 원칙을 지킬 것을 약속합니다. 절충이 필요한 경우:
- 명확한 이유와 함께 문서화
- 팀의 검토 및 승인
- 기술 부채를 해결할 계획과 함께 추적

이 헌법은 살아있는 문서이며 진화하는 표준과 모범 사례를 반영하기 위해 정기적으로 검토하고 업데이트해야 합니다.

---

*최종 업데이트: 2025-11-05*
